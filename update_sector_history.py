#!/usr/bin/env python3
# update_sector_history.py
# -----------------------------------------------------------
# Update the authentic sector history with data from the Finnhub API

import os
import pandas as pd
import numpy as np
import pytz
from datetime import datetime, timedelta
import json
import config
import time
# Import sector list from sentiment_engine if available, otherwise define a fallback list
try:
    from sentiment_engine import SECTORS
except ImportError:
    SECTORS = [
        "SMB SaaS", "Enterprise SaaS", "Cloud Infrastructure", "AdTech", "Fintech",
        "Consumer Internet", "eCommerce", "Cybersecurity", "Dev Tools / Analytics",
        "Semiconductors", "AI Infrastructure", "Vertical SaaS",
        "IT Services / Legacy Tech", "Hardware / Devices"
    ]

def generate_score(params):
    """
    Generate a standardized score in the range [-1, 1] from a raw value
    based on configurable parameters
    
    Args:
        params (dict): Dictionary with the following keys:
            raw_value (float): The raw value to convert to a score
            band_1 (float): The lower band threshold
            band_2 (float): The upper band threshold
            signal_cap (float): Cap for the signal (default: 2.0)
            inverse (bool): Whether to inverse the signal (default: False)
            
    Returns:
        float: Standardized score in the range [-1, 1]
    """
    # Extract parameters
    raw_value = params['raw_value']
    band_1 = params['band_1']
    band_2 = params['band_2']
    signal_cap = params.get('signal_cap', 2.0)
    inverse = params.get('inverse', False)
    
    # Calculate the base signal with proportional mapping in the neutral zone
    if raw_value < band_1:
        # Below band 1 - negative signal
        base_signal = -1.0
        # Allow stronger negative signals for values significantly below band_1
        if raw_value < band_1 - (band_2 - band_1):
            # Calculate how many multiples of the band width we are below band_1
            band_width = band_2 - band_1
            multiples_below = (band_1 - raw_value) / band_width
            # Apply signal_cap to limit maximum intensity
            base_signal = -min(signal_cap, 1.0 + multiples_below)
    elif raw_value > band_2:
        # Above band 2 - positive signal
        base_signal = 1.0
        # Allow stronger positive signals for values significantly above band_2
        if raw_value > band_2 + (band_2 - band_1):
            # Calculate how many multiples of the band width we are above band_2
            band_width = band_2 - band_1
            multiples_above = (raw_value - band_2) / band_width
            # Apply signal_cap to limit maximum intensity
            base_signal = min(signal_cap, 1.0 + multiples_above)
    else:
        # Within the bands - proportional signal between -1 and 1
        position_in_band = (raw_value - band_1) / (band_2 - band_1)
        base_signal = -1.0 + 2.0 * position_in_band
    
    # Apply inversion if specified
    if inverse:
        return -base_signal
    else:
        return base_signal

def load_sector_values():
    """Load the sector values from the CSV file generated by Finnhub API"""
    try:
        sector_values_path = "data/sector_values.csv"
        print(f"Attempting to load sector values from {sector_values_path}")
        if not os.path.exists(sector_values_path):
            print(f"Error: Sector values file not found at {sector_values_path}")
            return None
        
        # Display file contents for debugging
        with open(sector_values_path, 'r') as f:
            lines = f.readlines()
            print(f"First few lines of {sector_values_path}:")
            for i, line in enumerate(lines[:5]):
                print(f"Line {i+1}: {line.strip()}")
        
        df = pd.read_csv(sector_values_path)
        print(f"Successfully loaded CSV with columns: {df.columns.tolist()}")
        
        # Check for Date column
        if 'Date' not in df.columns:
            print(f"Warning: 'Date' column not found in {sector_values_path}")
            print(f"Available columns: {df.columns.tolist()}")
            # Try to find a suitable date column
            date_cols = [col for col in df.columns if 'date' in col.lower()]
            if date_cols:
                print(f"Using {date_cols[0]} as date column")
                df.rename(columns={date_cols[0]: 'Date'}, inplace=True)
            else:
                print("No date column found, cannot continue")
                return None
                
        df['Date'] = pd.to_datetime(df['Date'])
        print(f"Processed dates, date range: {df['Date'].min()} to {df['Date'].max()}")
        return df
    except Exception as e:
        print(f"Error loading sector values: {e}")
        import traceback
        traceback.print_exc()
        return None

def convert_to_sentiment_scores(sector_values_df):
    """Convert market cap values to sentiment scores using trend analysis"""
    try:
        if sector_values_df is None or sector_values_df.empty:
            return None
        
        # Sort by date to ensure proper ordering
        sector_values_df = sector_values_df.sort_values('Date')
        
        # Get the latest date
        latest_date = sector_values_df['Date'].max()
        latest_data = sector_values_df[sector_values_df['Date'] == latest_date]
        
        # Get previous date's data (typically 3 days prior for weekends)
        previous_date = sector_values_df['Date'].sort_values(ascending=False).iloc[1]
        previous_data = sector_values_df[sector_values_df['Date'] == previous_date]
        
        print(f"Using latest data from {latest_date} and previous data from {previous_date}")
        
        # For each sector, calculate a score based on growth from previous date
        scores = []
        for column in latest_data.columns:
            if column != 'Date':
                # Get the values for this sector
                latest_value = latest_data[column].iloc[0]
                previous_value = previous_data[column].iloc[0]
                
                print(f"Sector {column}: Latest={latest_value}, Previous={previous_value}")
                
                # Skip sectors with zero market cap in either period
                if latest_value == 0 or previous_value == 0:
                    print(f"  Skipping sector {column} due to zero values")
                    scores.append({
                        'sector': column,
                        'score': 0.0  # Default neutral score
                    })
                    continue
                
                # Calculate percent change from previous period
                percent_change = (latest_value - previous_value) / previous_value * 100
                print(f"  Percent change: {percent_change:.2f}%")
                
                # Map percent change to a score between -1 and 1
                # Using a sigmoid-like function to handle outliers
                # Consider: 
                # - 0% change = neutral (0.0 score)
                # - 1-3% change = moderately positive/negative (±0.5 score)
                # - 5%+ change = strongly positive/negative (approaching ±1.0 score)
                raw_score = min(1.0, max(-1.0, percent_change / 5.0))
                
                # Apply smoothing using our generate_score function
                normalized_score = generate_score({
                    'raw_value': raw_score,
                    'band_1': -0.2,  # Slightly negative
                    'band_2': 0.2,   # Slightly positive
                    'signal_cap': 2.0 # Cap for extreme values
                })
                
                print(f"  Final score: {normalized_score:.3f}")
                
                # Append to scores list
                scores.append({
                    'sector': column,
                    'score': normalized_score
                })
        
        return scores
    except Exception as e:
        print(f"Error converting to sentiment scores: {e}")
        import traceback
        traceback.print_exc()
        return None

def update_authentic_sector_history(scores):
    """Update the authentic sector history with new scores"""
    try:
        if scores is None or len(scores) == 0:
            print("No scores to update")
            return False
        
        # Load the existing authentic sector history
        history_path = "data/authentic_sector_history.csv"
        if os.path.exists(history_path):
            df = pd.read_csv(history_path)
            df['date'] = pd.to_datetime(df['date'])
        else:
            df = pd.DataFrame(columns=['date'])
        
        # Get today's date in Eastern time
        eastern = pytz.timezone('US/Eastern')
        today = datetime.now(eastern).strftime('%Y-%m-%d')
        
        # Check if we already have an entry for today
        if today in df['date'].dt.strftime('%Y-%m-%d').values:
            # Update existing row
            idx = df[df['date'].dt.strftime('%Y-%m-%d') == today].index[0]
            print(f"Updating existing entry for {today}")
        else:
            # Add new row
            new_row = pd.DataFrame({'date': [pd.Timestamp(today)]})
            df = pd.concat([df, new_row], ignore_index=True)
            idx = len(df) - 1
            print(f"Adding new entry for {today}")
        
        # Update values
        for sector_data in scores:
            sector_name = sector_data['sector']
            
            # Convert raw score from [-1,1] to [0-100] for display
            raw_score = sector_data['score']
            normalized_score = ((raw_score + 1.0) / 2.0) * 100
            
            # Add column if it doesn't exist
            if sector_name not in df.columns:
                df[sector_name] = None
            
            # Update value
            df.at[idx, sector_name] = normalized_score
            print(f"Updated {sector_name} score to {normalized_score:.1f}")
        
        # Save to CSV
        df.to_csv(history_path, index=False)
        
        # Also export today's data to date-specific CSV for direct download
        today_csv_path = f"data/authentic_sector_history_{today}.csv"
        today_df = df[df['date'].dt.strftime('%Y-%m-%d') == today]
        today_df.to_csv(today_csv_path, index=False)
        
        print(f"Saved authentic sector history to {history_path}")
        print(f"Exported today's scores to {today_csv_path}")
        
        return True
    except Exception as e:
        print(f"Error updating authentic sector history: {e}")
        return False

def main():
    """Main function to update the authentic sector history"""
    try:
        # Load the sector values from Finnhub API
        print("Loading sector values from Finnhub API...")
        sector_values_df = load_sector_values()
        if sector_values_df is None:
            print("Failed to load sector values")
            return False
        
        print(f"Loaded sector values for {len(sector_values_df)} dates")
        
        # Convert to sentiment scores
        print("Converting to sentiment scores...")
        scores = convert_to_sentiment_scores(sector_values_df)
        if scores is None:
            print("Failed to convert to sentiment scores")
            return False
        
        print(f"Generated {len(scores)} sector sentiment scores")
        
        # Update the authentic sector history
        print("Updating authentic sector history...")
        success = update_authentic_sector_history(scores)
        if success:
            print("Successfully updated authentic sector history")
        else:
            print("Failed to update authentic sector history")
        
        return success
    except Exception as e:
        print(f"Error in main update function: {e}")
        return False

if __name__ == "__main__":
    success = main()
    print(f"Update {'succeeded' if success else 'failed'}")

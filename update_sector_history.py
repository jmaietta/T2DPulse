#!/usr/bin/env python3
# update_sector_history.py
# -----------------------------------------------------------
# Update the authentic sector history with data from the Finnhub API

import os
import pandas as pd
import numpy as np
import pytz
from datetime import datetime, timedelta
import json
import config
import time
from sentiment_engine import generate_score

def load_sector_values():
    """Load the sector values from the CSV file generated by Finnhub API"""
    try:
        sector_values_path = "data/sector_values.csv"
        if not os.path.exists(sector_values_path):
            print(f"Error: Sector values file not found at {sector_values_path}")
            return None
        
        df = pd.read_csv(sector_values_path)
        df['Date'] = pd.to_datetime(df['Date'])
        return df
    except Exception as e:
        print(f"Error loading sector values: {e}")
        return None

def convert_to_sentiment_scores(sector_values_df):
    """Convert market cap values to sentiment scores using momentum"""
    try:
        if sector_values_df is None or sector_values_df.empty:
            return None
        
        # Sort by date to ensure proper ordering
        sector_values_df = sector_values_df.sort_values('Date')
        
        # Get the latest date
        latest_date = sector_values_df['Date'].max()
        latest_data = sector_values_df[sector_values_df['Date'] == latest_date]
        
        # If we don't have prior data for calculating momentum, use a simple approach
        # otherwise we would use the momentum calculation for each sector
        
        # For now, generate a score for each sector based on the raw values
        # We're using a simple transformation here that produces consistent scores
        scores = []
        for column in latest_data.columns:
            if column != 'Date':
                # Get the value for this sector
                value = latest_data[column].iloc[0]
                
                # Skip sectors with zero market cap (API errors or rate limiting)
                if value == 0:
                    continue
                
                # Generate a score for this sector between -1 and 1 using log scale since market caps vary widely
                # This is a temporary placeholder until we develop a more sophisticated model
                # We'll use a normalized approach to make scores consistent
                market_cap_billions = value / 1000000000  # Convert to billions for readability
                
                # Normalize large values using log
                if market_cap_billions > 0:
                    log_value = np.log10(max(market_cap_billions, 0.1))
                    # Normalize to [-1, 1] range assuming log values typically between -1 and 6
                    normalized_score = min(1, max(-1, (log_value - 2.5) / 3.5))
                else:
                    normalized_score = -1  # Default for zero or negative values
                
                # Convert to sentiment score with smoothing
                # Use the same approach as sentiment_engine.generate_score but simplified
                sentiment_score = generate_score({'raw_value': normalized_score, 
                                                 'band_1': -0.5, 
                                                 'band_2': 0.5, 
                                                 'signal_cap': 2.0})
                
                # Append to scores list
                scores.append({
                    'sector': column,
                    'score': sentiment_score
                })
        
        return scores
    except Exception as e:
        print(f"Error converting to sentiment scores: {e}")
        return None

def update_authentic_sector_history(scores):
    """Update the authentic sector history with new scores"""
    try:
        if scores is None or len(scores) == 0:
            print("No scores to update")
            return False
        
        # Load the existing authentic sector history
        history_path = "data/authentic_sector_history.csv"
        if os.path.exists(history_path):
            df = pd.read_csv(history_path)
            df['date'] = pd.to_datetime(df['date'])
        else:
            df = pd.DataFrame(columns=['date'])
        
        # Get today's date in Eastern time
        eastern = pytz.timezone('US/Eastern')
        today = datetime.now(eastern).strftime('%Y-%m-%d')
        
        # Check if we already have an entry for today
        if today in df['date'].dt.strftime('%Y-%m-%d').values:
            # Update existing row
            idx = df[df['date'].dt.strftime('%Y-%m-%d') == today].index[0]
            print(f"Updating existing entry for {today}")
        else:
            # Add new row
            new_row = pd.DataFrame({'date': [pd.Timestamp(today)]})
            df = pd.concat([df, new_row], ignore_index=True)
            idx = len(df) - 1
            print(f"Adding new entry for {today}")
        
        # Update values
        for sector_data in scores:
            sector_name = sector_data['sector']
            
            # Convert raw score from [-1,1] to [0-100] for display
            raw_score = sector_data['score']
            normalized_score = ((raw_score + 1.0) / 2.0) * 100
            
            # Add column if it doesn't exist
            if sector_name not in df.columns:
                df[sector_name] = None
            
            # Update value
            df.at[idx, sector_name] = normalized_score
            print(f"Updated {sector_name} score to {normalized_score:.1f}")
        
        # Save to CSV
        df.to_csv(history_path, index=False)
        
        # Also export today's data to date-specific CSV for direct download
        today_csv_path = f"data/authentic_sector_history_{today}.csv"
        today_df = df[df['date'].dt.strftime('%Y-%m-%d') == today]
        today_df.to_csv(today_csv_path, index=False)
        
        print(f"Saved authentic sector history to {history_path}")
        print(f"Exported today's scores to {today_csv_path}")
        
        return True
    except Exception as e:
        print(f"Error updating authentic sector history: {e}")
        return False

def main():
    """Main function to update the authentic sector history"""
    try:
        # Load the sector values from Finnhub API
        print("Loading sector values from Finnhub API...")
        sector_values_df = load_sector_values()
        if sector_values_df is None:
            print("Failed to load sector values")
            return False
        
        print(f"Loaded sector values for {len(sector_values_df)} dates")
        
        # Convert to sentiment scores
        print("Converting to sentiment scores...")
        scores = convert_to_sentiment_scores(sector_values_df)
        if scores is None:
            print("Failed to convert to sentiment scores")
            return False
        
        print(f"Generated {len(scores)} sector sentiment scores")
        
        # Update the authentic sector history
        print("Updating authentic sector history...")
        success = update_authentic_sector_history(scores)
        if success:
            print("Successfully updated authentic sector history")
        else:
            print("Failed to update authentic sector history")
        
        return success
    except Exception as e:
        print(f"Error in main update function: {e}")
        return False

if __name__ == "__main__":
    success = main()
    print(f"Update {'succeeded' if success else 'failed'}")

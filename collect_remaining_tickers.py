#!/usr/bin/env python3
# collect_remaining_tickers.py
# -----------------------------------------------------------
# Automated collection of remaining tickers with timing controls
# Generated by remaining_tickers_plan.py

import pandas as pd
import numpy as np
import yfinance as yf
import logging
import sys
import time
from datetime import datetime, timedelta

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('ticker_collection.log')
    ]
)
logger = logging.getLogger(__name__)

def update_historical_data(ticker, price=None, market_cap=None):
    """Update historical data files with new ticker data"""
    try:
        # Load data files
        price_df = pd.read_csv('data/historical_ticker_prices.csv', index_col=0)
        mcap_df = pd.read_csv('data/historical_ticker_marketcap.csv', index_col=0)
        
        # Get current date
        latest_date = price_df.index[-1]
        
        # Update data
        if price is not None:
            logger.info(f"Updating {ticker} price to {price}")
            price_df.loc[latest_date, ticker] = price
            
        if market_cap is not None:
            logger.info(f"Updating {ticker} market cap to {market_cap:,}")
            mcap_df.loc[latest_date, ticker] = market_cap
        
        # Save updated data
        price_df.to_csv('data/historical_ticker_prices.csv')
        mcap_df.to_csv('data/historical_ticker_marketcap.csv')
        
        return True
    except Exception as e:
        logger.error(f"Error updating historical data for {ticker}: {e}")
        return False

def fetch_ticker_data(ticker, retry_count=3, initial_delay=5):
    """Fetch ticker data with retry logic"""
    price = None
    market_cap = None
    
    for attempt in range(retry_count):
        delay = initial_delay * (2 ** attempt)
        logger.info(f"Attempt {attempt+1}/{retry_count} for {ticker} (delay: {delay}s)")
        time.sleep(delay)
        
        try:
            # Get price
            data = yf.Ticker(ticker).history(period='1d')
            if not data.empty:
                price = data['Close'].iloc[-1]
                logger.info(f"Got price for {ticker}: {price}")
            
            # Add delay between requests
            time.sleep(5)
            
            # Get market cap
            info = yf.Ticker(ticker).info
            market_cap = info.get('marketCap')
            if market_cap:
                logger.info(f"Got market cap for {ticker}: {market_cap:,}")
            
            if price is not None and market_cap is not None:
                break
                
        except Exception as e:
            logger.error(f"Error fetching {ticker} data: {e}")
    
    return price, market_cap

def execute_plan():
    """Execute the ticker collection plan"""
    try:
        plan = pd.read_csv('ticker_collection_plan.csv')
        logger.info(f"Loaded collection plan with {len(plan)} items")
        
        for _, item in plan.iterrows():
            ticker = item['ticker']
            scheduled_time = datetime.strptime(item['scheduled_time'], '%Y-%m-%d %H:%M:%S')
            data_needed = item['data_needed']
            
            # Calculate wait time until scheduled collection
            now = datetime.now()
            wait_time = (scheduled_time - now).total_seconds()
            
            if wait_time > 0:
                logger.info(f"Waiting {wait_time:.1f} seconds until scheduled time for {ticker}")
                time.sleep(wait_time)
            
            logger.info(f"Collecting data for {ticker} ({data_needed})")
            price, market_cap = fetch_ticker_data(ticker)
            
            # Update only needed data
            if data_needed == "price and market cap":
                update_historical_data(ticker, price, market_cap)
            elif data_needed == "price only":
                update_historical_data(ticker, price=price)
            elif data_needed == "market cap only":
                update_historical_data(ticker, market_cap=market_cap)
            
            # Additional delay after completion
            time.sleep(10)
            
        logger.info("Collection plan execution complete")
        
    except Exception as e:
        logger.error(f"Error executing collection plan: {e}")

if __name__ == "__main__":
    logger.info("Starting execution of ticker collection plan")
    execute_plan()
